"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Base api fetcher.
 */
var Fetcher =
/*#__PURE__*/
function () {
  /**
   * @param {Http} http
   * @param {string} [territory = 'TW'] - ['TW', 'HK', 'SG', 'MY', 'JP'] The territory for the fetcher.
   */
  function Fetcher(http) {
    var territory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'TW';

    _classCallCheck(this, Fetcher);

    /**
     * @ignore
     */
    this.http = http;
    /**
     * @ignore
     */

    this.territory = territory;
  }
  /**
   * Set the fetcher's territory.
   * @param {string} [territory = 'TW'] - ['TW', 'HK', 'SG', 'MY', 'JP'] The territory for the fetcher.
   * @return {Fetcher}
   */


  _createClass(Fetcher, [{
    key: "setTerritory",
    value: function setTerritory(territory) {
      this.territory = territory;
      return this;
    }
    /**
     * Gets an object's nested property by path.
     * @ignore
     */

  }, {
    key: "getPropertyByPath",
    value: function getPropertyByPath(object, path) {
      path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties

      path = path.replace(/^\./, ''); // strip a leading dot

      var keys = path.split('.');

      for (var i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i];

        if (key in object) {
          object = object[key];
        } else {
          return;
        }
      }

      return object;
    }
    /**
     * Fetches next page of various paged APIs.
     *
     * @param {fulfillment} fulfillment - The fulfillment get from Promose's onFulfillment function
     * @param {String} nextUriPath - The next uri's path. Defaults to 'data.paging.next',
     * which means we will get the next uri path from 'fulfillment.data.paging.next'.
     * The correct next uri path depends on respective api's response.
     * @return {Promise}
     * @example
     * api.albumFetcher
     *   .setAlbumID('KmRKnW5qmUrTnGRuxF')
     *   .fetchTracks()
     *   .then(response => {
     *     api.albumFetcher.fetchNextPage(response));
     *   });
     */

  }, {
    key: "fetchNextPage",
    value: function fetchNextPage(fulfillment) {
      var nextUriPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'data.paging.next';
      var nextUri = this.getPropertyByPath(fulfillment, nextUriPath);

      if (nextUri != null && nextUri !== undefined) {
        return this.http.get(nextUri);
      } else {
        return new Promise(function (resolve, reject) {
          reject(new Error('Cannot fetch next page'));
        });
      }
    }
    /**
     * Is next page available for various paged APIs.
     * @param {fulfillment} fulfillment - The fulfillment get from Promose's onFulfillment function
     * @param {String} nextUriPath - The next uri's path. Defaults to 'data.paging.next',
     * which means we will get the next uri path from 'fulfillment.data.paging.next'.
     * The correct next uri path depends on respective api's response.
     * @return {Boolean}
     * @example
     * api.albumFetcher
     *   .setAlbumID('KmRKnW5qmUrTnGRuxF')
     *   .fetchTracks()
     *   .then(response => {
     *     if (api.albumFetcher.hasNextPage(response)) {
     *       // more data available
     *     }
     *   });
     */

  }, {
    key: "hasNextPage",
    value: function hasNextPage(fulfillment) {
      var nextUriPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'data.paging.next';
      var nextUri = this.getPropertyByPath(fulfillment, nextUriPath);
      return nextUri != null && nextUri !== undefined;
    }
  }]);

  return Fetcher;
}();

exports["default"] = Fetcher;